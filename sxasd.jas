I need help integrating retry logic into my puppeteer navigation function. I have the following retry and verification pattern from my login function:

async function retry(fn, verifyFn, maxAttempts = 5) {
  let lastError;
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      await fn();
      if (verifyFn) {
        const isSuccess = await verifyFn();
        if (!isSuccess) {
          throw new Error("Action verification failed");
        }
      }
      return;
    } catch (error) {
      lastError = error;
      console.log(`Attempt ${attempt}/${maxAttempts} failed: ${error.message}`);
      if (attempt === maxAttempts) break;
      await new Promise((resolve) =>
        setTimeout(resolve, 1000 * Math.pow(2, attempt - 1))
      );
    }
  }
  throw new Error(
    `Failed after ${maxAttempts} attempts. Last error: ${lastError.message}`
  );
}

And here's my current login function showing how I use retry and element verification:

async function login(page, email, password) {
  try {
    await retry(
      async () => {
        await page.goto("https://www.printful.com/auth/login");
      },
      async () => {
        return await page.evaluate(() => {
          return window.location.href.includes("/auth/login");
        });
      }
    );

    await handleCookiePopup(page);

    await retry(
      async () => {
        const emailField = await ensureClickable(page, SELECTORS.LOGIN.EMAIL);
        await emailField.type(email);
      },
      async () => {
        const emailValue = await page.$eval(
          SELECTORS.LOGIN.EMAIL,
          (el) => el.value
        );
        return emailValue === email;
      }
    );

    await retry(
      async () => {
        const passwordField = await ensureClickable(
          page,
          SELECTORS.LOGIN.PASSWORD
        );
        await passwordField.type(password);
      },
      async () => {
        const passwordValue = await page.$eval(
          SELECTORS.LOGIN.PASSWORD,
          (el) => el.value.length > 0
        );
        return passwordValue;
      }
    );

    await retry(
      async () => {
        const submitButton = await ensureClickable(
          page,
          SELECTORS.LOGIN.SUBMIT
        );
        await Promise.all([
          submitButton.click(),
          page.waitForNavigation({ waitUntil: "networkidle0" }),
        ]);
        await verifyLoginSuccess(page);
      },
      async () => {
        return await verifyLoginSuccess(page);
      }
    );
  } catch (error) {
    console.error("Login failed:", error.message);
    throw error;
  }
}

I also have this helper function to ensure elements are clickable:

async function ensureClickable(page, selector, timeout = 10000) {
  await page.waitForSelector(selector, {
    visible: true,
    timeout,
  });

  const element = await page.$(selector);
  if (!element) {
    throw new Error(`Element ${selector} not found`);
  }

  const isClickable = await page.evaluate((el) => {
    const rect = el.getBoundingClientRect();
    return (
      rect.width > 0 &&
      rect.height > 0 &&
      window.getComputedStyle(el).display !== "none" &&
      window.getComputedStyle(el).visibility !== "hidden" &&
      !el.disabled
    );
  }, element);

  if (!isClickable) {
    throw new Error(`Element ${selector} is not clickable`);
  }

  return element;
}

Can you help me implement similar retry and verification logic for my store navigation function:

async function navigateToCatalog(page, searchTerm) {
    console.log(searchTerm)
    try {
        const storesNavButton = await ensureClickable(page, SELECTORS.NAVIGATION.CATALOG);
        await storesNavButton.click();
        await wait(5000);

        await page.type("#sitewide-search-input", searchTerm, {
            delay: 10
        });
        await wait(3000);
        
        const searchedItems = await page.$$(".sitewide-search__item--product");
        console.log(searchedItems, "searchItems");

        for (const item of searchedItems) {
            await item.click();
            await page.waitForNavigation();
            await wait(3000);

            await page.evaluate(() => {
                const buttonGroup = document.querySelector(".product-action-buttons__wrapper");
                if (buttonGroup) {
                    buttonGroup.scrollIntoView({
                        behavior: "smooth",
                        block: "center",
                    });
                }
            });

            const buttons = await page.$$(".product-action-buttons__wrapper button");
            for (const button of buttons) {
                try {
                    const buttonText = await button.evaluate((el) => {
                        return el.textContent.trim().replace(/\s+/g, " ");
                    });
                    if (buttonText === "Create product template") {
                        await button.click();
                        await wait(4000);
                        
                        // Prevent default file input behavior before clicking upload button
                        await page.evaluate(() => {
                            // Remove any existing file input event listeners
                            const originalAddEventListener = Element.prototype.addEventListener;
                            Element.prototype.addEventListener = function (type, listener, options) {
                                if (type === 'click' && this.classList.contains('product-push__droparea')) {
                                    return; // Don't add click listeners for this element
                                }
                                originalAddEventListener.call(this, type, listener, options);
                            };
                            
                            // Disable any file inputs
                            const fileInputs = document.querySelectorAll('input[type="file"]');
                            fileInputs.forEach(input => {
                                input.disabled = true;
                            });
                        });
                        
                        // Now try to click the upload button
                        await clickUploadButton(page);
                        await handleModalButton(page,"saveTemplate")
                    }
                } catch (error) {
                    console.error("Error processing button:", error);
                }
            }
        }
    } catch (error) {
        console.error("Store navigation failed:", error.message);
        throw error;
    }
}

Please make it follow the same pattern as the login function with proper error handling, verification, and retry logic.