I need help integrating retry logic into my puppeteer navigation function. I have the following retry and verification pattern from my login function:

async function retry(fn, verifyFn, maxAttempts = 5) {
  let lastError;
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      await fn();
      if (verifyFn) {
        const isSuccess = await verifyFn();
        if (!isSuccess) {
          throw new Error("Action verification failed");
        }
      }
      return;
    } catch (error) {
      lastError = error;
      console.log(`Attempt ${attempt}/${maxAttempts} failed: ${error.message}`);
      if (attempt === maxAttempts) break;
      await new Promise((resolve) =>
        setTimeout(resolve, 1000 * Math.pow(2, attempt - 1))
      );
    }
  }
  throw new Error(
    `Failed after ${maxAttempts} attempts. Last error: ${lastError.message}`
  );
}

And here's my current login function showing how I use retry and element verification:

async function login(page, email, password) {
  try {
    await retry(
      async () => {
        await page.goto("https://www.printful.com/auth/login");
      },
      async () => {
        return await page.evaluate(() => {
          return window.location.href.includes("/auth/login");
        });
      }
    );

    await handleCookiePopup(page);

    await retry(
      async () => {
        const emailField = await ensureClickable(page, SELECTORS.LOGIN.EMAIL);
        await emailField.type(email);
      },
      async () => {
        const emailValue = await page.$eval(
          SELECTORS.LOGIN.EMAIL,
          (el) => el.value
        );
        return emailValue === email;
      }
    );

    await retry(
      async () => {
        const passwordField = await ensureClickable(
          page,
          SELECTORS.LOGIN.PASSWORD
        );
        await passwordField.type(password);
      },
      async () => {
        const passwordValue = await page.$eval(
          SELECTORS.LOGIN.PASSWORD,
          (el) => el.value.length > 0
        );
        return passwordValue;
      }
    );

    await retry(
      async () => {
        const submitButton = await ensureClickable(
          page,
          SELECTORS.LOGIN.SUBMIT
        );
        await Promise.all([
          submitButton.click(),
          page.waitForNavigation({ waitUntil: "networkidle0" }),
        ]);
        await verifyLoginSuccess(page);
      },
      async () => {
        return await verifyLoginSuccess(page);
      }
    );
  } catch (error) {
    console.error("Login failed:", error.message);
    throw error;
  }
}

I also have this helper function to ensure elements are clickable:

async function ensureClickable(page, selector, timeout = 10000) {
  await page.waitForSelector(selector, {
    visible: true,
    timeout,
  });

  const element = await page.$(selector);
  if (!element) {
    throw new Error(`Element ${selector} not found`);
  }

  const isClickable = await page.evaluate((el) => {
    const rect = el.getBoundingClientRect();
    return (
      rect.width > 0 &&
      rect.height > 0 &&
      window.getComputedStyle(el).display !== "none" &&
      window.getComputedStyle(el).visibility !== "hidden" &&
      !el.disabled
    );
  }, element);

  if (!isClickable) {
    throw new Error(`Element ${selector} is not clickable`);
  }

  return element;
}

Can you help me implement similar retry and verification logic for my store navigation function:

async function clickChooseMockupsButton(page) {
    try {
      console.log("Attempting to find and click Choose mockups button...");
  
      // Wait for any loading indicators to disappear
      try {
        await page.waitForSelector(SELECTORS.MOCKUP.LOADING_INDICATOR, {
          hidden: true,
          timeout: 5000,
        });
      } catch (loadingError) {
        console.log("No loading indicator found or already hidden");
      }
  
      // Multiple methods to find the Choose mockups button
      const buttonSelectors = [
        ".mockup-type-picker a.pf-btn.pf-btn-secondary.pf-btn-block--mobile",
        // Direct text content match
        'button:has-text("Choose mockups")',
        // Data test attribute if available
        'button[data-test="choose-mockups-btn"]',
        // Class-based selector if specific class exists
        ".mockup-selection-button",
        // XPath as fallback
        '//button[contains(text(), "Choose mockups")]',
      ];
      await wait(2000);
      let button = null;
      for (const selector of buttonSelectors) {
        try {
          button = await page.waitForSelector(selector, {
            visible: true,
            timeout: 5000,
          });
          if (button) {
            console.log(`Found button using selector: ${selector}`);
            break;
          }
        } catch (err) {
          console.log(`Selector ${selector} not found, trying next...`);
        }
      }
  
      if (!button) {
        throw new Error("Choose mockups button not found with any selector");
      }
  
      // Ensure button is visible and clickable
      await page.evaluate((btn) => {
        if (btn) {
          btn.scrollIntoView({
            behavior: "smooth",
            block: "center",
          });
        }
      }, button);
  
      await wait(1000); // Wait for scroll to complete
  
      // Attempt to click the button using multiple methods
      try {
        // Method 1: Direct click
        await button.click({
          delay: 100,
        });
      } catch (clickError) {
        console.log("Direct click failed, trying alternative methods");
        try {
          // Method 2: Page click
          await page.click('button:has-text("Choose mockups")');
        } catch (pageClickError) {
          // Method 3: Evaluate click
          await page.evaluate(() => {
            const buttons = Array.from(document.querySelectorAll("button"));
            const chooseMockupsBtn = buttons.find(
              (btn) => btn.textContent.trim().toLowerCase() === "choose mockups"
            );
            if (chooseMockupsBtn) {
              chooseMockupsBtn.click();
            }
          });
        }
      }
      await wait(3000);
      // Verify that the click worked by waiting for the mockup grid
      // await page.waitForSelector(SELECTORS.MOCKUP.MOCKUP_GRID, {
      //     visible: true,
      //     timeout: 10000
      // });
  
      console.log("Successfully clicked Choose mockups button");
      return true;
    } catch (error) {
      console.error("Error in clickChooseMockupsButton:", error);
      throw error;
    }
}

Please make it follow the same pattern as the login function with proper error handling, verification, and retry logic.